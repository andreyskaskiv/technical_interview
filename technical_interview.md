**1. Что такое pep8?**  
Pep или Python Enhancement Proposal – это предложения по развитию языка Python. pep8 – это стайл-гайд того, как должен
быть оформлен код, написан на языке Python и которому должны следовать все разработчики, которые пишут на этом языке.

---

**2. Какие типы данных есть в Python или какие типы данных изменяемые, а какие неизменяемые?**  
Типы данных в Python можно разглядеть на изменяемые и неизменяемые.

- Mutable: list, set, dict, bytearray, memoryview.
- Immutable: str, bytes, int, float, complex, bool, None, tuple, frozenset.

---

**3. Что такое виртуальное окружение? Зачем оно может быть нужно и какие инструменты для этого используются?**   
Когда мы используем виртуальные окружения, мы тем самым создаем что-то по типу песочницы, где мы изолируем локальный
Python от глобального Python, это позволяет нам ставить различные библиотеки локально, не влияя на Python,
который установлен в глобально у нас на компьютере.

---

**4. Возможно ли изменить элемент в кортеже, если кортеж неизменяемый тип данных?**   
Кортеж неизменяемый тип данных, менять структуру его нельзя. Но если есть изменяемые элементы внутри, то их можно
менять.

```python
a = ([], 1)
a[0].append(2)

print(a)
([2], 1)
```

---

**5. Что такое List, Set и Dict Comprehensions? Приведи пример о их использовании.**

```python
print([i for i in range(5) if i % 2 == 0])
print({i: i * 3 for i in range(5) if i % 2 == 0})

[0, 2, 4]
{0: 0, 2: 6, 4: 12}
```

Как примеры использования List, Dict Comprehension это просто распаковка каких-то коллекций, либо каких-то генераторов,
либо просто замена какого-нибудь очень простого цикла, когда это не мешает читабельности кода.

---

**6. Какая разница между операторами `==` и `is`?**  
`==` - сравнивает два операнда по значению
`is` - по адресам в памяти

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)
print(a is b)

True
False
```

---

**7. Что такое глубокая и поверхностная копия, зачем они нужны и как их сделать?**  
Tак как они ссылаются на один и тот же объект в памяти, то b тоже поменялся:

```python
a = [1, [2]]
b = a

b.append(3)
b[1].append(4)

print(a)

[1, [2, 4], 3]
```

Поверхностная копия создаёт копию самого объекта, но ссылки на все внутренние объекты будут сохранены, они не будут
скопированы:

```python
import copy

a = [1, [2]]
b = copy.copy(a)

b.append(3)
b[1].append(4)

print(a)

[1, [2, 4]]
```

Как сделать глубокую копию?

```python
import copy

a = [1, [2]]
b = copy.deepcopy(a)

b.append(3)
b[1].append(4)

print(a)

[1, [2]]
```

Поверхностно копия она копирует сам объект, все внутренние объекты она не копирует, они доступны по тем же ссылкам.
Глубокая копия, она мало того, что копирует внешний объект, она рекурсивно копирует все внутренние объекты в новую
память.

Как можно создать поверхностную копию?

```python
a = [1, [2]]
b = list(a)
b = a[:]
b = [i for i in a]
b = a.copy()
```

---

**8. Как работают операторы AND, OR и NOT? Что они возвращают?**   
Оператор NOT действительно приводит объект к какому-то болевого значения.

```python
print(not [])
print(not [1, 2, 3])

print(not {})
print(not {1, 2, 3})

True
False

True
False

```

Операторы AND и OR не приводят объекты к болевым значениям, они возвращают сами объекты.
AND проверяет, является ли первый оператор true либо false. И если первый оператор является true, то
AND возвращает второй оператор, потому что этого достаточно для всего условия. Если же первый оператор равняется false,
то он возвращает просто его. То есть, еще раз, первый оператор, если эквалентен false, возвращает первый оператор. Если
эквалентен true, возвращает второй оператор.

```python
#     (False and 123)
print([] and 123)

[]
```

```python
#     (True and 123)
print([1] and 123)

123
```

Как работает OR? Чтобы OR было правдой, нам достаточно, чтобы какой-то из операторов был правдой.
Соответственно, мы проверяем первый оператор. Если он эквалентен true, то мы возвращаем его. Если же он эквалентен
false, то возвращаем второй оператор.

```python
#     (False or 123)
print([] or 123)

123
```

```python
#     (True or 123)
print([1] or 123)

1
```

---

**9. Как работает разрешение пространства имен в Python или как работает правило LEGB(Local, Enclosing, Global,
Built-in)?**

```python
str = "global"


def outer():
    str = "enclosing"

    def inner():
        str = "local"
        print(str)

    inner()


outer()

local
```

```python
str = "global"


def outer():
    str = "enclosing"

    def inner():
        # str="local"
        print(str)

    inner()


outer()

enclosing
```

```python
str = "global"


def outer():
    # str = "enclosing"

    def inner():
        # str="local"
        print(str)

    inner()


outer()

global
```

```python
# str = "global"

def outer():
    # str = "enclosing"

    def inner():
        # str="local"
        print(str)

    inner()


outer()

# <class 'str'>
```

---

**10. Как работают операторы global и enclosing?**

```python
a = 1  # global


def outer():
    b = 1

    def inner():
        a = 2
        b = 2

    inner()
    # Глобально мы ничего не поменяли
    print("a = ", a)
    print("b = ", b)


outer()

a = 1
b = 1
```

```python
a = 1  # global


def outer():
    b = 1

    def inner():
        global a  # в данном контексте меняем значение в глобальной области видимости
        a = 2

        nonlocal b  # меняе значение для внешней облости видимости
        b = 2

    inner()
    print("a = ", a)
    print("b = ", b)


outer()

a = 2
b = 2
```

---

**11. Знакомы ли тебе такие функции, как map, filter, zip? Приведи примеры их использования.**  
`map` — это такая функция, которая может быть применина к коллекции. Она применяет некоторую функцию к каждому элементу
нашей коллекции.

```python
print(*map(lambda x: x ** 2, [i for i in range(5)]))  # получим map-object, то есть это генератор и распакуем 

# 0 1 4 9 16
```

`filter` - фильтр также применяет некоторую функцию к каждому элементу этой последовательности. Если функция, которая
указана нулевым аргументом возвращает true, этот элемент остается в последовательности. Если false, то нет.

```python
print(*filter(lambda x: x % 2 == 0, [i for i in range(5)]))  # получим filter-object, то есть это генератор и распакуем 

# 0 2 4
```

`zip` - может сразу пройтись по нескольким коллекциям.

```python
a = [1, 2, 3]
b = [4, 5, 6, 7]
c = [8, 9]

print(*[i for i in zip(a, b, c)])

(1, 4, 8)(2, 5, 9)
```

---

**12. Как оценивается сложность алгоритмов и почему? Что такое Big-O?**  
Алгоритмическая сложность оценивается в Big-O. Big-O – это метод оценки, который определяет, как изменяется затраты на
выполнение, в зависимости от величины входных данных.   
Какая алгоритмическая сложность основных операций в коллекциях?

- Если мы говорим про список, в основном это будет линейная сложность, за исключением тех операций, которые выполняются
  в конце списка.
- Если мы говорим про set и dict, то в основном это будет сложность за единицу, потому что set и dict под капотом
  являются хэштаблицами.

---

**13. Что такое функция и какие преимущества использования функций?**  
Функция – это именованный блок кода, которым можно обратиться или вызвать из другого места программы. Основой их
преимущества – это повторное использование кода(DRY).

---

**14. Какой будет результат выполнения функции, если в ней нет оператора return?**  
`None`
То есть, если в функции нет оператора return, то она неявно возвращает `None`.

---

**15. Что такое аннотации типов? Зачем они нужны и когда выполняются аннотации типов?**  
Аннотации типов – это своеобразные подсказки, какого типа аргумента мы ожидаем где-то получить, это подсказки для самих
программистов.
В Python аннотации не работают в runtime. То есть, они не используют для проверки типов. Мы в любом случае можем
передать аргумент любого типа. Как правило, ими пользуются IDE и линтеры. Но есть ряд исключений.
Например, это библиотека Pydentic, которая может использовать аннотации типа в runtime для проверки типа данных,
например, атрибута класса.

---

**16. Как в Python передаются аргументы в функцию?**   
Есть два типа передачи аргументов в функцию. Это по ссылке и по значению. Конкретно в Python все аргументы в функцию
передаются по ссылке.

```python
a = [1, 2, 3]


def some(arg):
    print(arg is a)


some(a)

True
```

---

**17. Что будет, если использовать значение изменяемого типа в качестве аргумента по умолчанию в функции? И как этого
избежать?**

```python
def sum(a=[]):
    a.append(1)
    return a


print(sum())
print(sum([]))
print(sum())
print(sum([]))

[1]
[1]
[1, 1]
[1]
```

Когда Python читает наш код и натыкается на ассигнатуру функции sum, он читает аргументы этой функции, у нас
есть тут значение пустой список. Это значение он вычисляет, не когда мы вызываем эту функцию каждый раз, а на момент,
когда эта функция подготовится к выполнению. То есть, когда Python первый раз читает эту функцию, он вычисляет значения,
которые мы задали по умолчанию, кладет их в память, и в последующем они будут использованы каждый раз, когда мы будем
вызывать эту функцию. То есть, не будут создаваться каждый раз, а будут каждый раз использоваться те самые, которые были
вычислены первоначально.

Как этого избежать?

```python
def sum(a=None):
    if a is None:
        a = []
    a.append(1)
    return a


print(sum())
print(sum([]))
print(sum())
print(sum([]))

[1]
[1]
[1]
[1]
```

---

**18. Что такое `*args` и `**kwargs`? Какие типы данных для них используются?**   
`*args` и `**kwargs` это особые аргументы, которые позволяют принять нам неограниченное количество аргументов.

```python
def some(*args, **kwargs):
    print(locals())


some(1, 2, 3, a=4, b=5, c=6)

{'args': (1, 2, 3), 'kwargs': {'a': 4, 'b': 5, 'c': 6}}
```

---

**19. Что такое лямбда-функция?**   
Лямбда-функция это функция, у которой нет имени. Как правило, это какая-то короткая функция, которая выполняет некоторое
одно действие. И нам просто не нужно выделять для этого какое-то отдельное имя.

```python
a = {
    1: 33,
    2: 22,
    3: 11,
}

print(max(a))

3  # получаем самый большой ключ в словаре
```

```python
a = {
    1: 33,
    2: 22,
    3: 11,
}

print(max(a, key=lambda x: a[x]))

1  # ключ, у которого самое большое значение
```

---

**20. Что такое рекурсия? Какие ограничения есть у рекурсии в Python? И расскажи о плюсах и минусах использования
рекурсии.**   
Рекурсия – это механизм, когда функция вызывает саму себя. Это может потребоваться для, например, изменения входных
аргументов снова и снова, чтобы получить какой-то некоторый результат, либо же для прохождения некоторой вложенной
коллекции.
Какие могут быть плюсы? Плюсы – это то, что код будет относительно просто выглядеть. Минусы – это то, что рекурсия
использует больше памяти, нежели, например, если мы будем решать с помощью использования цикла. Большинство
рекурсий можно заменить решением с циклом.

```python
def factorial(n):
    if n == 1:
        return n
    else:
        return n * factorial(n - 1)
```

```python
def factorial(n):
    num = 1
    while n >= 1:
        num = num * n
        n = n - 1
    return num
```

Python накладывает ограничение в 1000 вызовов на рекурсию.

```python
import sys

print(sys.getrecursionlimit())

1000
```

```python
import sys

sys.setrecursionlimit(2000)
print(sys.getrecursionlimit())

2000
```

---

**20. Что такое класс?**  
Класс – это модель для создания объектов определенного типа, который описывает их структуру и поведение.

---

**21. Тогда что такое объект класса?**  
Объект класса – это некоторая уникальная сущность определенного типа, то есть класса, который обладает структурой и
поведением.

---

**22. Как реализовать метод объекта и что такое self?**  
Чтобы вызвать метод объекта создать непосредственно объект. Что значит, что метод принадлежит объекту? Это значит, что
этот метод характеризует поведение конкретного объекта. И вызвать мы его можем только из объекта.

```python
class Person:
    name: str

    def __init__(self, name):
        self.name = name

    def say_hi(self):
        print(f"Hi, my name is {self.name}")


p = Person("Slava")
p.say_hi()

# Hi, my name is Slava
```

Методы объекта первым аргументом принимают self. Self – это ссылка на сам объект, который мы создали.

---

**23. Как реализовать метод класса и что такое `cls`?**  
`cls` - класс-метод мы можем вызывать без создания объекта класса.

```python
class Person:
    workplace = "My Company"

    @classmethod
    def get_my_word_place(cls):
        return cls.workplace


print(Person.get_my_word_place())

p = Person()
print(p.get_my_word_place())

# My Company
# My Company
```

Метод класса - принадлежит всему классу целиком. Он первым аргументом получает `cls`, это
ссылка на сам класс.

---

**24. Как реализовать статический метод?**
Статические методы по умолчанию не принимают ничего. Да, они конечно могут принимать какие-то аргументы, которые им
нужны, но они не принимают self или cls как какой-то специальный атрибут. Статический метод можно вызывать из класса.
Также его можно вызывать из объекта класса.

```python
import datetime


class A:
    @staticmethod
    def get_current_datetime():
        return datetime.datetime.now()


print(A.get_current_datetime())

p = A()
print(p.get_current_datetime())

# 2023-05-10 18:57:50.871539
# 2023-05-10 18:57:50.871539

```

Зачем же нам нужны статические методы внутри класса, если они не имеют доступа ни к объекту, ни к самому классу? Это
может потребоваться просто потому, что нам удобно поместить этот самый метод внутри этого класса. Когда это может быть
удобно? - Если этот метод часто используется внутри данного класса, либо же мы хотим поместить группу методов, чтобы потом
импортировать класс где-то в другом месте нашей программы и все их использовать с помощью имени данного класса.

---

**25. В Python нет модификаторов доступа и все по умолчанию это public. Как в Python реализуется public, private и
protected методы и атрибуты?**

```python
class A:
    public = 123
    _protected = 123
    __private = 123
```

**26. Как получить доступ к private атрибуту либо методу из объекта?**  
Чтобы получить доступ к private атрибуту либо методу из объекта, нам нужно сперва создать сам объект. А напрямую доступ
получить не получится. Если напишу этот объект, он не содержит атрибута private. Почему это так? Потому что Python
искажает имена приватных атрибутов и чтобы получить доступ к этому приватному атрибуту, мне нужно написать следующую
конструкцию:

```python
class A:
    public = 123
    _protected = 123
    __private = 123


a = A()
print(a._A__private)

123
```

**27. Как в классах хранятся атрибуты и методы?**
Во всех классах атрибуты и методы хранятся в специальном дандер атрибуте Dict. Это будет словарь, в котором ключ
значения хранятся все атрибуты

```python
class A:
    public = 123
    _protected = 123
    __private = 123

    def some(self):
        print("instance method")

    @classmethod
    def some_classmethod(cls):
        print("class method")

    @staticmethod
    def some_staticmethod():
        print("staticmethod")


print(A.__dict__)
```

**28. Чем отличается атрибут класса от атрибута объекта? И возможно ли использовать одинаковое имя для атрибута класса и
атрибута объекта?**  
Атрибут класса это некоторый атрибут, который общий для всех объектов этого класса. То есть если мы
поменяем это значение в классе, новое значение получит все его объекты. Атрибут объекта это та характеристика, которая
характеризует конкретный объект, то есть это свойства конкретного объекта. Если мы меняем свойства у какого-то объекта,
то она меняется только у него.

```python
class A:
    class_attr = 1

    def __init__(self):
        self.instance_attr = 2
```

Далее, возможно ли использовать одинаковое имя для атрибута класса и атрибута объекта?
Как я уже говорил ранее, классы используют дикт для хранения атрибутов и методов. Также дикта используются для хранения
данных внутри объекта. Соответственно, если мы пытаемся использовать одинаковое имя и для атрибута класса, и для
атрибута объекта, это возможно. Они друг другу не мешают, просто потому, что они хранятся в разных словарях. Как это
можно проверить?

```python
class A:
    attr = 1

    def __init__(self):
        self.attr = 2


a = A()

print(A.attr)
print(a.attr)
print(A.attr)

1
2
1
```

Но как понимать, что вот этот атрибут, он не перезаписал вот этот вот. Можно либо принтануть еще раз a. Видим, что
значение не перезаписалось. Почему же так произошло? Если мы посмотрим на `a.__dict__`, увидим, что тут есть наш
атрибут. Если же мы посмотрим на `A.__dict__`, тут также есть атрибут объекта. То есть это просто два разных словаря,
которые друг другу не мешают.

**29. Зачем нужен декоратор property?**

```python
class Person:
    first_name: str
    last_name: str

    def __init__(self, first_name: str, last_name: str):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

```

Property позволяет создать динамический атрибут. В данном кейсе мы можем, например, описать декоратор property.
Как интерфейс можно заметить, что property они очень похожи на атрибуты, но на самом деле это функции, которые
выполняются в runtime и динамически рассчитывают это значение.

```python
p = Person("Andrey", "Sky")
print(p.full_name)

# Andrey Sky
```

Также к property мы можем написать setter. Для этого нужно указать собака, имя property, setter.

```python
class Person:
    first_name: str
    last_name: str

    def __init__(self, first_name: str, last_name: str):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    @full_name.setter
    def full_name(self, value: str):
        name_surname = value.split(" ")
        self.first_name = name_surname[0]
        self.last_name = name_surname[1]


p = Person("Andrey", "Sky")
p.full_name = "Name Surname"
print(p.first_name)
print(p.last_name)

# Name
# Surname
```

**30. Что такое абстрактный класс? Зачем они нужны и как они реализуются в Python?**  
В Python у нас нет интерфейсов, поэтому вместо них мы используем абстрактные классы. Для этого мы должны описать
некоторый класс, например animal. Он должен быть наследником класса abc из модуля abc. Если мы просто наследуем класс от
abc, то он еще не будет абстрактным. Что значит, что класс абстрактный? Это значит, что объект этого класса нельзя
создать. Этот класс он просто определяет интерфейс для классов потомков, и этот интерфейс он должен быть обязательно
реализован. Например, сейчас я могу создать объект этого класса, это значит, что он не абстрактный.

```python
from abc import ABC


class Animal(ABC):
    pass


a = Animal()
```

Чтобы он стал абстрактным, мне необходимо создать какой-то абстракт-метод.

```python
from abc import ABC, abstractmethod


class Animal(ABC):
    @abstractmethod
    def say_something(self):
        raise NotImplemented


a = Animal()

# TypeError: Can't instantiate abstract class Animal with abstract method say_something
```

Что мы делаем дальше? Создаем дочерний класс, который будет, например, cat. Наследуем класс animal. Если я не реализовал
это самый абстрактный метод, то cat это тоже абстрактный класс. Если я попытаюсь создать его объект, я получу ту же
самую ошибку,
что этот класс абстрактный, потому что в нем не реализован метод say something. Что мне надо сделать далее? Это всего
лишь в классе переопределить этот метод. Я метод переопределил, теперь я могу создать объект этого класса, а класс
перестал быть абстрактным.

```python
from abc import ABC, abstractmethod


class Animal(ABC):
    @abstractmethod
    def say_something(self):
        raise NotImplemented


class Cat(Animal):
    def say_something(self):
        print("Meaw")


c = Cat()
```

Абстрактный класс, он определяет интерфейс для дочерних классов, который обязателен к реализации.

**31. Какая разница между методами `__new__` и `__init__`, и какой из них вызывается первым?**   
В Python нет такого понятия, как конструктор. У нас конструктор разделяется на метод, который создает объект, и на
метод, который инициализирует объект. Метод, который создает объект, это метод  `__new__`. Его задача создать некоторые
объекты, вернуть его из этого метода. Далее у нас есть метод  `__init__`, он отвечает за инициализацию объекта, то есть
он получает уже готовый созданный объект и забивает его какими-то атрибутами. Первый из них будет вызываться `__new__`,
соответственно для создания объекта `__init__` будет вызываться потом, чтобы этот объект наполнился какими-то
атрибутами. Сперва вызывался new, потом вызывался init.

```python
class A:
    def __new__(cls, *args, **kwargs):
        print("NEW")
        obj = super().__new__(cls, *args, **kwargs)
        return obj

    def __init__(self):
        print("INT")
        self.some = 1


a = A()

# NEW
# INT
```

**32. Какая разница между методами str и repr и какой из них использовать?**
И тот, и тот метод, он отвечает за строковое представление объекта. Разница лишь в том, что str, он отвечает за
строковое представление, которое ближе к пользователю, а repr отвечает за формальное представление объекта, то есть
которое ближе к машине.
Если же мы создадим какой-то объект этого класса и выполним просто print объект этого класса, то по умолчанию у меня
отработает str.

```python
class Cat:
    name: str

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"Cat(name='{self.name}')"

    def __str__(self):
        return f"It is my cat {self.name}"


c = Cat(name="Barsik")
print(c)

# It is my cat Barsik
```

Если же у меня str нет, то будет метод print искать repr, который определен в данном классе.

```python
class Cat:
    name: str

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"Cat(name='{self.name}')"

    # def __str__(self):
    #     return f"It is my cat {self.name}"


c = Cat(name="Barsik")
print(c)

# Cat(name='Barsik')
```

Если же и этого метода нет, то будет отрабатывать стандартный repr, который определен уже в классе object.

```python
class Cat:
    name: str

    def __init__(self, name):
        self.name = name

    # def __repr__(self):
    #     return f"Cat(name='{self.name}')"

    # def __str__(self):
    #     return f"It is my cat {self.name}"


c = Cat(name="Barsik")
print(c)

# <__main__.Cat object at 0x0000020118C86950>
```

Если же нам конкретно нужно получить repr, то помимо функций print есть также функции и repr, которые мы можем
использовать с объектом этого класса, чтобы обратиться непосредственно не к str, а к методу repr.

```python
class Cat:
    name: str

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"Cat(name='{self.name}')"

    def __str__(self):
        return f"It is my cat {self.name}"


c = Cat(name="Barsik")
print(repr(c))

# Cat(name='Barsik')
```

Какой из них использовать? Если же нам объект нужно печатать в какой-то строке, либо где-то еще и представлять данные на
вид пользователю, то нужно использовать str. Если же мы используем объект в принтах, либо где-то еще в строках, для того
чтобы использовать это в логах каких-нибудь, то скорее всего вам пригодится repr.

**33. Зачем может быть использована функция super?**   
Функция super может быть использована для того, чтобы обратиться к методу родительского класса. Чаще всего это
встречается в инициализаторах. Например, у меня есть класс A, в котором я переопределил инициализатор, который принимает
некоторое a и записывает это в instance attribute. Также у меня есть класс B, который наследуется от A. В нем я также
переопределил инициализатор, который принимает и a, и b. Чтобы создать атрибут класса a, потому что он этого требует,
мне необходимо вызывать super init и передать туда a. Далее я могу забить атрибуты класса b с помощью self. Также стоит
отметить, что функция super, она ищет методы согласно mro.

```python
class A:
    def __init__(self, a):
        self.a = a


class B:
    def __init__(self, a, b):
        super().__init__(a)
        self.b = b
```

**34. Что такое OOP?**   
OOP, или объектно-ориентированное программирование, это методология программирования, которая основана на представлении
программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют
иерархию наследования.

**35. Какие базовые принципы OOP?**

- абстракция,
- наследование,
- полиморфизм,
- инкапсуляция.

**36. Что такое абстракция?**   
Абстракция — это использование только тех характеристик объекта, которые с достаточной точностью представляют его. Нужно
представить объект минимальным набором полей и методов, и при этом с достаточной точностью для решаемой задачи.

**37. Что такое наследование?**   
Наследование — это принцип OOP, согласно которому мы можем создать некоторый класс на основе предыдущего класса,
предыдущий класс будет называться родителем, а новый класс будет называться дочерним. Дочерний класс будет
получать весь функционал родительского класса, и можем и расширять этот функционал.

```python
class A:
    a = 1

    def a_method(self):
        print("A instance method")


class B(A):
    b = 2

    def b_method(self):
        print("B instance method")


b = B()
print(b.b)  # объект имеет доступ и к методам и атрибутам текущего класса
print(b.b_method())  # b_method также существует здесь
print(b.a_method())  # имеем доступ и к a_method, который определен в родительском классе
print(b.a)  # к атрибуту a, который такжеопределен в родительском классе

# 2
# B instance method
# A instance method
# 1
```

**38. Когда лучше использовать наследование, а когда композицию?**  
Наследование это когда мы берем какой-то класс, создаем его полностью на основе родительского класса.
Композиция это когда мы создаем какой-то класс и некоторый класс используем в качестве части данного класса – это может
быть атрибут класса либо атрибут обьекта.

```python
class A:
    pass


class B(A):
    pass


class C:
    a = A()
```

При наследовании мы получаем весь функционал родительского класса и потом не можем это переопределить. При композиции мы
можем на лету поменять этот атрибут на какой-то другой, если нам нужен класс не A, а класс D, например. Если же нам
нужен весь функционал родительского класса, то мы используем наследование. Если же нам нужен функционал, но в
последующем, возможно, нам потребуется его переопределить на функционал из другого класса. Либо же мы хотим обращаться к
родительскому классу как к атрибуту этого класса, то нам нужно использовать композицию.

**39. Что такое инкапсуляция?**   
Инкапсуляция может пониматься двояко. Если же мы говорим про Python, то первая трактовка будет такая. Инкапсуляция это
объединение переменных и функций, которые привержены общей цели в классе. Вторая трактовка будет — это разграничение
абстракций от реализации, то есть тем самым это может быть достигнуто с помощью реализации сеттеров и геттеров и
датахайдинга.

**40. Что такое полиморфизм и какие типы полиморфизма есть Python?**  
Выделяют два типа полиморфизма — это ad-hoc-полиморфизм и параметрический полиморфизм. Начнем с параметрического
полиморфизма. Это означает, что у нас есть какая-то функция, выполнение которой не зависит от типа аргумента, который
она принимает.
То есть у нас есть класс A, и у нас есть класс B, у них есть одинаковые функции, но они не под типы
какого-то одного общего класса. У нас функция sum может работать со всеми объектами типов данных, у которых просто есть
функция hi. И нам неважно, передадим в нее мы объект класса A, это будет работать либо объект класса B. То есть в данном
случае мы получаем параметрический полиморфизм.

```python
class A:
    def hi(self):
        print(f"Hi from A")


class B:
    def hi(self):
        print(f"Hi from B")


def some(obj):
    obj.hi()


some(A())
some(B())

# Hi from A
# Hi from B
```

Что же тогда такое ad-hoc-полиморфизм? Тогда функция может иметь множество имплементаций в зависимости от
типов входящих аргументов. Так, например, работают в языках C++, в джаве. Но в Python изначально у нас нет такого
функционала, но мы можем его реализовать с помощью своих рук. Например, вот функция to_json в зависимости от типов
входящих данных, она может возвращать различные значения.

```python
def to_json(value):
    if isinstance(value, int):
        return str(int)
    if isinstance(value, float):
        return str(int)
    if isinstance(value, str):
        return f"{value}"
    if isinstance(value, list):
        return '[' + ','.join(to_json(x) for x in value) + ']'
```

**41. Что такое mixin и чем mixin отличается от обычного класса?**  
Далее у нас есть mixin, S3FileUploadMixin. Этот mixin отвечает только за то, чтобы некоторые файлы загрузить в конкретно
S3 Также у нас есть класс CSVDocument, который будет содержать реализацию некоторых специфичных методов конкретно для
CSV документа. И он наследует и Document и S3FileUploadMixin. В чем же разница между обычным классом и классом mixin?
Для обычного класса мы скорее всего захотим создавать его объект. Для класса mixin нет, потому что класс mixin он будет
содержать, как правило, некоторую мелкую логику, которую мы можем подмешивать с помощью наследования, поэтому он и
называется mixin. То есть Python это тот язык, который поддерживает множество наследования, соответственно мы можем
подмешивать эти mixins в любом порядке, в любом количестве. Тем самым наш дочерний класс может получать собственно
некоторый функционал. Допустим, это может быть CSVDocument, который мы хотим чтобы умел загружаться в s3. Потом мы
захотим создавать например WordDocument, ExcelDocument, который тоже захотим грузить в s3. Мы просто будем подмешивать
вот этот mixin в эти классы и он будет получать этот самый функционал.

```python
class Document:
    pass


class S3FileUploadMixin:
    pass


class CSVDocument(Document, S3FileUploadMixin):
    pass

```

**42. Что такое замыкание?**  
Замыкание это механизм, когда одна функция использует перемены из внешней области видимости.
Например, у нас есть функция add_number, которая будет принимать какой-то a, у нас также есть функция add, которая будет
принимать какой-то b, но в свою очередь три функции add мы используем перемену из внешней области видимости, то есть из
функции add_number.

```python
def add_number(a):
    def add(b):
        return a + b

    return add


add_five = add_number(5)

print(add_five(3))
print(add_five(10))

8
15
```

**43. Что такое декоратор и зачем нужны декораторы?**   
Декоратор — это паттерн проектирования, он может быть нужен затем, чтобы изменить поведение функции либо класса, без
изменения исходного кода функции либо класса.
Канонически декоратор реализуется с помощью классов, но в Python есть две замечательные вещи. Во-первых, у нас есть
синтетический сахар с помощью символа `@`, во-вторых, у нас есть принцип, что функция — это объект первого класса, это
значит, что функцию можно передать в другую функцию в качестве аргумента и вернуть из другой функции в качестве
результата.
Так вот, чтобы реализовать декоратор, нам необходимо реализовать замыкание, которое принимает функцию. Внутри этого
декоратора мы пишем функцию обертку, которая будет пробрасывать аргументы в нашу исконную функцию. Далее, мы можем
выполнить какие-то действия до выполнения нашей функции, потом вызвать эту саму функцию, передав в нее аргументы,
выполнить действия после нашей функции и вернуть результат, тем самым мы добавляем какое-то дополнительное поведение до
и какое-то дополнительное поведение после. Чтобы применить весь декоратор какой-то функции, достаточно использовать
синтетический сахар @decorator, потом соответственно код нашей функции, далее мы можем просто вызвать нашу функцию
sayHi и увидеть, что она выполняется уже с кодом декоратора.

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("BEFORE")
        result = func(*args, **kwargs)
        print("AFTER")

        return result

    return wrapper


@decorator
def say_hi(name):
    print(f"Hi, my name is {name}")
    return 1
```

**44. Как реализовать декоратор, который может принимать аргументы?**   
Чтобы реализовать декоратор, который может принимать аргументы, у нас появляются просто дополнительные уровни
вложенности. У нас все также есть декоратор, который принимает функцию, у которой внутри есть wrapper, который выполняет
эту функцию, но также у нас появляется внешний слой, это просто функция, которая принимает какие-то аргументы, который в
будущем должен принимать этот самый декоратор и возвращает вложенный декоратор. Чтобы применить декоратор с аргументами
к функции, надо просто указать с помощью синтетического сахара `@`имя декоратора, передать в него необходимые аргументы,
далее мы просто можем вызвать нашу функцию с ожидаемыми аргументами и видеть, что декоратор наш работает. В данном кейсе
он повторяет выполнение func 3 раза.

```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print("BEFORE")
            result = []
            for _ in range(n):
                r = func(*args, **kwargs)
                result.append(r)
            print("AFTER")
            return result

        return wrapper

    return decorator


@repeat(3)
def say_hi(name):
    print(f"Hi, my name is {name}")
    return 1


say_hi("Andrey")

# BEFORE
# Hi, my name is Andrey
# Hi, my name is Andrey
# Hi, my name is Andrey
# AFTER
```

**45. Что такое итерируемый объект (iterable)?**   
Итерируемый объект — это объект, который предоставляет возможность поочередного прохода по своим элементам.

**46. Что такое итератор? Как создать итератор из коллекции?**  
Разница между iterable и итератор в том, что iterable реализует метод iter, в свою очередь, итератор реализует метод
iter и next.
Как создать итератор из некоторой коллекции? Для этого нам потребуется какая-нибудь коллекция, например, это будет
список. Далее мы можем вызвать функцию iter над этим списком, чтобы получить итератор. iter принимает iterable,
соответственно мы передаем ей a. Если мы принесем i, то у нас есть лист iterator.
Как можно убедиться, что это на самом деле итератор? У него должен быть метод next, мы должны получить true. Да, все
верно.

```python
a = [1, 2, 3]
i = iter(a)
print(i)
print("__next__" in dir(i))

# <list_iterator object at 0x00000215961FBE50>
# True
```

Далее мы можем из этого итератора по требованию брать некоторые следующие элементы с помощью функции next. 1, 1, 2 и так
далее.

```python
a = [1, 2, 3]
i = iter(a)

print(next(i))
print(next(i))

1
2
```

**47. Как сделать класс, который будет поддерживать протокол итератора?**

Далее, у класса, который будет поддерживать протокол итератора, должно быть два метода. Это метод iter. Метод iter
должен вернуть iterable. В данном случае мы просто вернем self. Также должен быть метод next. Метод next должен
вернуть следующий элемент из коллекции. Это будет current. Далее, как с этим работать? Можно создать объект этого
класса и работать с ним в цикле. Видим, что мы подряд получаем элементы.

```python
class Counter:
    current: int

    def __init__(self):
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        current = self.current
        self.current += 1
        return current


c = Counter()
for i in c:
    print(i)
```

Либо же мы можем создать итератор. И с помощью функции next получаем следующий элемент.

```python
class Counter:
    current: int

    def __init__(self):
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        current = self.current
        self.current += 1
        return current


c = Counter()

i = iter(c)

print(next(i))
print(next(i))
print(next(i))

0
1
2
```

**48. Что такое генератор, как написать на Python генератор и какие преимущества использования генератора
относительно функций?**  
Синтактические генераторы отличаются от функций немногим, мы можем просто написать некоторую
функцию и вместо return указать у нее внутри yield. Тем самым мы получим генератор.

```python
def some():
    yield 1
```

Какие преимущества использования генератора относительно функций? Это то, что генератор может вызываться по требованию.
То есть мы можем создать объект генератора, когда мы эту функцию вызываем, то есть выполняем.
Мы не получаем ее результат, а мы получаем объект генератора.

```python
def some():
    yield 1


obj = some()
print(obj)
print(next(obj))

# <generator object some at 0x000001BA15E0B690>
1
```

Далее, из этого объекта генератора мы можем по требованию забирать следующее значение с помощью функции next. Когда
таких значений не останется, то мы получим stop iteration, ошибку. И из этого вытекают основные преимущества
использования генератора относительно функций, что мы можем код выполнять по требованию тогда, когда нам это нужно. В
свою очередь, же когда функция, она выполняется полностью до конца, до ключевого слова return, либо до конца своего
блока кода и возвращает полностью весь результат. Соответственно, генератор, он может на ходу нам возвращать или
генерирует какие-то значения функции, возвращает всю коллекцию целиком. Вот это и есть основное преимущество
использования генератора относительно функций.

**49. Что такое generator comprehension?**

```python
a = (i for i in range(5))

print(a)

# <generator object <genexpr> at 0x00000172D36A8110>
```

Что дальше можно с ним сделать?

```python
a = (i for i in range(3))

for i in a:
    print(i)

0
1
2
```

```python
a = (i for i in range(3))

print(next(a))
print(next(a))

0
1
```

**50. Может ли в одном генераторе быть много yield? Если да, то как это работает?**   
Напишем простой генератору, у которого внутри будет несколько yield, сразу отвечая на вопрос «да, это возможно», как это
будет работать? Сперва мы должны создать объект генератора. Напоминаю, что в этот момент код у нас внутри не стартует,
мы просто создаем объект генератора. Далее, когда мы выполняем в первый раз функцию next, то наш код доходит до первого
yield и возвращает значение, которое указано справа от yield. Мы получаем единицу. Далее, этот код останавливается на
этом моменте, и генератор запоминает на каком моменте он остановился. При следующем next мы стартуем от момента, когда
он остановился, до следующего yield, то есть тем самым мы получим два, и снова наш генератор остановится. Если мы
вызовем next еще раз, мы уже получим три. Если еще раз, наши значения закончились, больше нет yield в генераторе,
соответственно, мы получим stop iteration.

```python
def some():
    yield 1
    yield 2
    yield 3


s = some()  # создали объект генератора

print(next(s))
print(next(s))
print(next(s))
```

**51. Зачем нужна конструкция yield from?**  
Представим такую ситуацию, что мне нужно во втором генераторе вернуть все значения из первого генератора.

```python
def first():
    yield 1
    yield 1


def second():
    yield from first()  # верни все значения из генератора first
    yield 2
    yield 2


s = second()  # создаем объект генератора second

for i in s:
    print(i)

1
1
2
2
```

Сперва он вернет все значения с первого генератора, потому что мы указали yield from первый генератор, далее он будет
возвращать свои значения.

**52. Что такое менеджер контекста?**  
Менеджер контекста это конструкция `with ... as ...`, которая позволяет нам обратиться к какому-то объекту, получить
какой-то другой объект и далее работать внутри этого контекста. Если возникнет какое-то исключение, то у нас есть
специальный код, который может это исключение обработать.

**53. Как реализовать класс, объект которого может работать в менеджере контекста? Что будет присвоено после as? Какие
аргументы принимает __exit__ метод?**  
Чтобы реализовать класс, который может работать в менеджере контекста, нам нужно реализовать два магических метода.
Первый это `__enter__`, второй это `__exit__`. Метод `__enter__` это метод объекта, в котором мы просто описываем
действия, которые необходимо выполнить по входу в контекст. Это действия, которые связаны непосредственно с вашей
задачей. Это может быть открытие файла, открытие соединений или что-нибудь еще. Метод `__exit__` в свою очередь он
выполняется по закрытию контекста, либо когда у нас возникает exception в данном контексте. Он принимает self, потому
что это метод объекта. Далее он принимает тип ошибки, которая возникла внутри контекста, значение этой самой ошибки и
traceback. То есть в данном методе `__exit__` мы можем выполнить какие-то действия, чтобы эту ошибку может быть
залогировать, как-то обработать и так далее.

```python
class Connection:
    def __enter__(self):  # действия, которые необходимо выполнить по входу в контекст
        self.connection = 1

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.connection = 0
```

Как это будет работать? После with мы создаем объект. Далее вызывается метод `__enter__`. У нас создается как бы
соединение. В контексте мы можем провести какие-то действия. Когда мы покидаем контекст, то у нас будет выполняться
метод `__exit__`, в котором будет закрываться наше соединение. Если возникнет какая-то ошибка, то `__exit__` получит
exc_type, значение exc_val и exc_tb, информацию о traceback по этой ошибке.

```python
class Connection:
    def __enter__(self):  # действия, которые необходимо выполнить по входу в контекст
        self.connection = 1

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.connection = 0


with Connection() as obj:
    print("SOME")
    raise Exception("VAL")
```

**54. Какие блоки для обработки исключения существуют в Python? Когда каждый из них выполняется?**    
В Python существует четыре блока для обработки исключения.

- try - выполняется всегда. В нем мы помещаем какой-то код, который может вылетать с ошибкой.
- accept - выполняется только в том случае, если try завершился с какой-то ошибкой, который ловит этот самый accept.
- else - выполняется в том случае, если try выполнился без ошибок.
- finally - выполняется в любом случае.

**55. Можно ли использовать несколько accept? Если да, то как это будет работать?**   
Да, несколько accept можно использовать, они будут обрабатывать в порядке их очередности. То есть ошибка, которую мы
вызываем в блоке try, либо которая возникает в каком-то блоке, она будет сравниваться с типом ошибки, который указан в
accept. Если он подходит, то эта ошибка будет использована.
Например, в данном случае кидаю ValueError, то первый блок он отрабатывает.

```python
try:
    raise ValueError(1)
except ValueError:
    print("ValueError")
except Exception:
    print("Exception")

ValueError
```

Если это будет ошибкой Exception, то будет обрабатываться второй блок.

```python
try:
    raise Exception(1)
except ValueError:
    print("ValueError")
except Exception:
    print("Exception")

Exception
```

Но тут важно помнить о порядке этих самых исключений.
Например, если первым исключением я укажу как раз такие Exception, а вторым ValueError, Exception он является
базовым исключением для ValueError. То есть он является родителем для класса ValueError. Соответственно, ValueError он
будет подходить под Exception, и блок, который ловит ValueError, он никогда не сработает. Давайте проверим.

```python
try:
    raise ValueError(1)
except Exception:
    print("Exception")
except ValueError:
    print("ValueError")

Exception
```

Видим, что у нас отрабатывает только exception. ValueError никогда в данном случае не сработает.

**56. Можно ли одним блоком except ловить несколько типов исключений?**  
Да, можно. Для этого нужно указать в картеже типы исключений, которые мы ожидаем отловить данным except.

```python
try:
    raise ValueError(1)
except (ValueError, TypeError):
    print("Value or Type Error")
```

**57. В чем разница между except и except Exception?**  
except Exception — это тот except, который ловит конкретный тип исключения, то есть Exception. Exception — это базовый
класс для всех Python ошибок. except без ничего он ловит так называемый base Exception. Base exception — это базовый
класс для всех ошибок. Exception является его дочерним классом. Помимо Exception, там есть некоторые дополнительные
ошибки по типу GeneratorExit, SystemExit и так далее.

Попробуем немного воспроизвести данную ситуацию. Сделаем raise ValueError. ValueError — это дочерний класс от exception.
Соответственно, первый except у меня должен отработать.

```python
try:
    raise ValueError
except Exception:
    print("Exception")
except:
    print("Base Exception")

Exception
```

Далее попробуем кинуть GeneratorExit. В данном случае у нас работает Base Exception, потому что Exception не включает в
себя GeneratorExit.

```python
try:
    raise GeneratorExit
except Exception:
    print("Exception")
except:
    print("Base Exception")

# Base Exception
```

Как переподнять исключение в блоке except (reraise exception)? Допустим, у меня есть какой-то внутренний блок
try except, либо это может быть try except внутри какой-то функции, которую мы выполняем в блоке try. Неважно. И внутри
там происходит ошибка.

```python
try:
    try:
        raise ValueError(1)
    except Exception:
        print("INNER")
except Exception:
    print("OUTER")
```

У нас есть какой-то обработчик, который ловит этот тип ошибки, и далее мы можем ее обработать, залогировать и так далее.
Но если мы эту ошибку INNER except, то далее внешний обработчик ее не словит, потому что эта ошибка уже была обработана.
Что надо делать, если нам нужно эту ошибку поднять вверх по стеку? Как это сделать? В данном случае нам просто
достаточно написать ключевое слово raise. Если мы запустим этот код, мы увидим, что ее обработал и внутренний обработчик
и внешний обработчик.

```python
try:
    try:
        raise ValueError(1)
    except Exception:
        print("INNER")
        raise
except Exception:
    print("OUTER")

INNER
OUTER
```

**58. Зачем нужны классы BaseExceptionGroup и ExceptionGroup?**
BaseExceptionGroup и ExceptionGroup позволяет нам кинуть сразу много исключений за раз. Например, у нас работает
какой-то код, который собирает какие-то типы ошибок. Мы можем это все обернуть в ExceptionGroup, дать туда какое-то
название общей всех тех же ошибок и собрать тут какое-то количество n ошибок. Они могут быть разных типов, это неважно.
Также тут может быть вложенный ExceptionGroup, это тоже будет работать. Можем дальше разнуть эту ExceptionGroup и
Exception ее словить и как-то обработать эти ошибки вместе либо как-то по отдельности. Это будет работать.

```python
try:
    eg = ExceptionGroup(
        "exception group", [
            TypeError(1),
            ValueError(2),
        ]
    )
    raise eg

except ExceptionGroup as e:
    print(e)

# exception group (2 sub-exceptions)
```

Для чего тогда нужен BaseExceptionGroup? Если допустим у нас ошибка, это какая-то ошибка, которая является дочерним
классом от BaseException, например, GeneratorExit, то ExceptionGroup тут не будет работать, потому что он не может
обернуть этот тип ошибки. В данном случае нам нужен BaseExceptionGroup. Соответственно, нам нужно поменять в коде на
BaseExceptionGroup отлов и это опять будет работать.

```python
try:
    eg = BaseExceptionGroup(
        "exception group", [
            TypeError(1),
            GeneratorExit(2),
        ]
    )
    raise eg

except BaseExceptionGroup as e:
    print(e)

# exception group (2 sub-exceptions)
```

**59. В чем разница между `except` и `except*`? И зачем нужен `except*`?**  
`except*` это функционал, который появился также в Python 3.11. Он облегчает работу с ExceptionGroup.
Допустим, мы кидаем ExceptionGroup, которая содержит несколько типов исключений. Например, там TypeError, ValueError,
неважно. Далее мы можем указать не просто except, а except*, где указан типа ошибки, которые мы ожидаем получить.
Первый except* с TypeError, второй с ValueError.
Что будет происходить? Мы кидаем ExceptionGroup. Наша ExceptionGroup будет распакована на несколько ExceptionGroup.
Первый Except обработает только TypeError, то есть он получит новый ExceptionGroup, который будет содержать только
TypeError. Второй Except он также будет обработан, то есть он будет выполняться. Он получит новый ExceptionGroup,
который будет содержать только ValueError. Если мы запустим код, то видим, что два Except отработали. Первый на
TypeError, второй на ValueError. В каждом по одному Exception, потому что так у меня указано в ExceptionGroup.

```python
try:
    eg = ExceptionGroup(
        "exception group", [
            TypeError(1),
            ValueError(2),
        ]
    )
    raise eg

except* TypeError as e:
    print("TypeError", e)
except* ValueError as e:
    print("ValueError", e)

# TypeError exception group (1 sub-exception)
# ValueError exception group (1 sub-exception)
```

Также важно уточнение, что except* и обычный except они не могут быть в одном блоке Try. Это не будет работать. То есть
либо мы ловим на конкретные ошибки, либо мы используем except*, которая нам позволяет более легким образом работать с
ExceptionGroup.

**60. Как создать свой тип исключения? Зачем может потребоваться создавать свой тип исключения?**  
Свой тип исключения создать несложно. Для этого достаточно отнаследоваться от какого-то базового исключения.

```python
class Custom(Exception):
    pass

```

И в большинстве кейсов этого будет достаточно. Зачем мы будем это делать? Зачем создавать custom исключения? Для того,
чтобы если мы поднимаем это исключение, мы получали более информативный вывод. То есть не просто exception, а просто
название custom. Когда это может помочь? Например, что у нас есть какой-то специфичный клиент, например, клиент, который
коннектится к какой-то другой third-party API, и мы хотим указать, что этот exception он относится только к этому
клиенту.
Когда мы можем создать какой-то custom exception и кидать его там, где нужно. Также есть возможность эти
exception и кастомазить. Как правило, это происходит с помощью переопределения `__init__`.

```python
class Custom(Exception):
    def __init__(self, value, message="Default message"):
        self.value = value
        self.message = message
        super().__init__(self.message)


raise Custom(123)

# Custom: Default message
```

**61. Что такое модуль?**  
Модуль – это файл с расширением .py, который содержит код на Python.

**62. Что такое пакет?**   
Пакет – это некоторая диктория, которая содержит Python модули. Также она может содержать файл `__init__.py`.
До версии 3.3 это условие было обязательным для существования пакета, чтобы был файл `__init__.py`. После 3.3 это уже
является не обязательным.

**63. Когда выполняется файл `__init__.py`и как много раз он будет выполнен?**   
`__init__.py` нам нужен для того, чтобы указать инструкции, которые будут выполняться при импорте пакета либо модуля из
этого пакета. Он выполняется только один раз, когда Python в первый раз натыкается на импорт соответственно пакета либо
его модуля.

**64. Когда возникает проблема циклического импорта и как ее решить?**   
Проблема циклического импорта возникает тогда, когда два модуля пытаются импортировать какие-то данные друг с другом.
Как это можно решить? Обычно это решается тем, что в третьем модуле мы разрешаем как-то эти конфликты, импортируем
какие-то переменные. В третьем модуле потом он где-то используется дополнительно. 
